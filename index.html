<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚ú® Cute Square Snakes ‚ú®</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: 'Comic Neue', 'Segoe UI', 'Fredoka', cursive, sans-serif;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
    }
    body {
      background: linear-gradient(145deg, #fffac2 0%, #e0ffc7 50%, #c7ffd9 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      padding: 20px;
    }
    
    /* Bubble background */
    .bubbles {
      position: fixed;
      width: 100%;
      height: 100%;
      z-index: 0;
      overflow: hidden;
      top: 0;
      left: 0;
      pointer-events: none;
    }
    
    .bubble {
      position: absolute;
      bottom: -100px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      animation: rise 10s infinite ease-in;
      box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.8);
    }
    
    .bubble:nth-child(1) {
      width: 80px;
      height: 80px;
      left: 10%;
      animation-duration: 8s;
    }
    
    .bubble:nth-child(2) {
      width: 40px;
      height: 40px;
      left: 20%;
      animation-duration: 6s;
      animation-delay: 1s;
    }
    
    .bubble:nth-child(3) {
      width: 110px;
      height: 110px;
      left: 35%;
      animation-duration: 12s;
      animation-delay: 2s;
    }
    
    .bubble:nth-child(4) {
      width: 25px;
      height: 25px;
      left: 45%;
      animation-duration: 4s;
      animation-delay: 0s;
    }
    
    .bubble:nth-child(5) {
      width: 65px;
      height: 65px;
      left: 55%;
      animation-duration: 9s;
      animation-delay: 3s;
    }
    
    .bubble:nth-child(6) {
      width: 35px;
      height: 35px;
      left: 65%;
      animation-duration: 7s;
      animation-delay: 2s;
    }
    
    .bubble:nth-child(7) {
      width: 90px;
      height: 90px;
      left: 75%;
      animation-duration: 11s;
      animation-delay: 1s;
    }
    
    .bubble:nth-child(8) {
      width: 45px;
      height: 45px;
      left: 85%;
      animation-duration: 5s;
      animation-delay: 4s;
    }
    
    .bubble:nth-child(9) {
      width: 70px;
      height: 70px;
      left: 92%;
      animation-duration: 10s;
      animation-delay: 0s;
    }
    
    .bubble:nth-child(10) {
      width: 30px;
      height: 30px;
      left: 15%;
      animation-duration: 5s;
      animation-delay: 5s;
    }
    
    @keyframes rise {
      0% {
        bottom: -100px;
        transform: translateX(0);
      }
      50% {
        transform: translateX(20px);
      }
      100% {
        bottom: 100vh;
        transform: translateX(-20px);
      }
    }
    
    .game-container {
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(10px);
      padding: 2rem 2rem 1.5rem;
      border-radius: 4rem;
      box-shadow: 0 20px 40px rgba(180, 230, 180, 0.5), inset 0 0 0 4px white;
      border: 4px solid rgba(255, 255, 255, 0.8);
      position: relative;
      z-index: 2;
      width: fit-content;
      max-width: 100%;
      margin: 20px auto;
    }
    
    canvas {
      display: block;
      margin: 0 auto;
      border-radius: 3rem;
      box-shadow: 0 0 0 6px white, 0 20px 30px rgba(150, 220, 150, 0.5);
      background-color: rgba(255, 255, 240, 0.8);
      max-width: 100%;
      height: auto;
      width: 800px;
      backdrop-filter: blur(2px);
    }
    
    .panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1.5rem;
      gap: 2rem;
      flex-wrap: wrap;
    }
    
    .left {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
    }
    
    input, button, select {
      background: rgba(255, 255, 255, 0.9);
      border: 3px solid #c7ffb0;
      color: #5f8b5f;
      padding: 0.7rem 1.5rem;
      border-radius: 3rem;
      font-size: 1.1rem;
      font-weight: 600;
      outline: none;
      transition: all 0.2s;
      backdrop-filter: blur(5px);
    }
    
    input::placeholder {
      color: #b0d6b0;
    }
    
    button {
      background: #e0ffd0;
      color: #4f7a4f;
      border: none;
      box-shadow: 0 5px 0 #b0e0b0;
      cursor: pointer;
      font-weight: bold;
      transform: translateY(0);
    }
    
    button:active {
      box-shadow: 0 2px 0 #b0e0b0;
      transform: translateY(3px);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 5px 0 #b0e0b0;
    }
    
    select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='%234f7a4f'><path d='M7 10l5 5 5-5z'/></svg>");
      background-repeat: no-repeat;
      background-position: right 1rem center;
      padding-right: 3rem;
    }
    
    .skin-selector {
      display: flex;
      gap: 0.8rem;
      flex-wrap: wrap;
    }
    
    .skin-btn {
      width: 3rem;
      height: 3rem;
      border-radius: 1.5rem;
      border: 3px solid white;
      transition: 0.1s;
      cursor: pointer;
      box-shadow: 0 4px 0 #c7ffb0;
    }
    
    .skin-btn[data-skin="0"] {
      background: #ffff7f;  /* Light yellow */
    }
    
    .skin-btn[data-skin="1"] {
      background: #bfff6f;  /* Lime */
    }
    
    .skin-btn[data-skin="2"] {
      background: #b4ffb4;  /* Light green */
    }
    
    .skin-btn.selected {
      border-color: #6fbf6f;
      transform: scale(1.15);
      box-shadow: 0 0 20px #b4ffb4;
    }
    
    .scoreboard {
      color: #4f7a4f;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.9);
      padding: 0.6rem 1.5rem;
      border-radius: 3rem;
      border: 3px solid #c7ffb0;
      font-size: 1.1rem;
      backdrop-filter: blur(5px);
    }
    
    .share-link {
      margin-top: 1.2rem;
      text-align: center;
      color: #5f8b5f;
      font-size: 0.9rem;
      background: rgba(255, 255, 255, 0.9);
      padding: 0.5rem;
      border-radius: 2rem;
      word-break: break-all;
      backdrop-filter: blur(5px);
    }
    
    h2 {
      text-align: center;
      color: #4f7a4f;
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
      text-shadow: 2px 2px 0 rgba(255, 255, 255, 0.8);
    }
    
    .loading {
      text-align: center;
      color: #4f7a4f;
      font-size: 1.2rem;
      margin-top: 1rem;
      background: rgba(255, 255, 255, 0.9);
      padding: 0.5rem;
      border-radius: 2rem;
      backdrop-filter: blur(5px);
    }
    
    .game-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      z-index: 1000;
      display: none;
      justify-content: center;
      align-items: center;
    }
    
    .respawn-box {
      background: rgba(255, 255, 255, 0.95);
      padding: 3rem;
      border-radius: 4rem;
      text-align: center;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      border: 4px solid #c7ffb0;
    }
    
    .respawn-box h3 {
      color: #4f7a4f;
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }
    
    .respawn-box p {
      color: #5f8b5f;
      font-size: 1.3rem;
      margin-bottom: 2rem;
    }
    
    .respawn-box button {
      font-size: 1.5rem;
      padding: 1rem 3rem;
    }
    
    /* Mobile responsiveness */
    @media (max-width: 900px) {
      .game-container {
        padding: 1rem;
      }
      canvas {
        width: 100%;
        height: auto;
      }
      .panel {
        flex-direction: column;
        align-items: stretch;
      }
      .left {
        justify-content: center;
      }
      .respawn-box {
        padding: 2rem;
        margin: 1rem;
      }
      .respawn-box h3 {
        font-size: 2rem;
      }
    }
  </style>
  <script src="/socket.io/socket.io.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Bubbles Background -->
  <div class="bubbles">
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
  </div>

  <!-- Respawn Overlay -->
  <div class="game-overlay" id="respawnOverlay">
    <div class="respawn-box">
      <h3>üíî You Died! üíî</h3>
      <p>Your snake got booped!</p>
      <button id="respawnBtn">‚ú® Respawn ‚ú®</button>
    </div>
  </div>

  <div class="game-container">
    <h2>üêç Cute Square Snakes üêç</h2>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div class="panel">
      <div class="left">
        <input type="text" id="nameInput" placeholder="Your name" maxlength="16" value="Cutie">
        <div class="skin-selector" id="skinSelector">
          <div class="skin-btn selected" data-skin="0" title="Light yellow cutie"></div>
          <div class="skin-btn" data-skin="1" title="Lime cutie"></div>
          <div class="skin-btn" data-skin="2" title="Light green cutie"></div>
        </div>
        <select id="controlMode">
          <option value="mouse">üê≠ Mouse Follow</option>
          <option value="keyboard" selected>‚å®Ô∏è Keyboard (Arrows/WASD)</option>
        </select>
        <button id="joinBtn">‚ú® Play ‚ú®</button>
      </div>
      <div class="scoreboard" id="scoreboard">Players: 0</div>
    </div>
    <div class="share-link" id="shareUrl"></div>
    <div class="loading" id="loadingStatus">Connecting to server...</div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nameInput = document.getElementById('nameInput');
    const joinBtn = document.getElementById('joinBtn');
    const respawnBtn = document.getElementById('respawnBtn');
    const scoreboard = document.getElementById('scoreboard');
    const shareUrl = document.getElementById('shareUrl');
    const loadingStatus = document.getElementById('loadingStatus');
    const respawnOverlay = document.getElementById('respawnOverlay');
    const controlMode = document.getElementById('controlMode');

    // Better socket connection for Render
    const socket = io({
      transports: ['websocket', 'polling'],
      reconnectionAttempts: 10,
      reconnectionDelay: 1000
    });

    let players = {};
    let food = [];
    let myId = null;
    let currentSkin = 0;
    let myPlayer = null;
    let mouseX = 0;
    let mouseY = 0;
    let targetDirection = { dx: 1, dy: 0 };
    let animationFrame = null;
    let lastDirectionSend = 0;
    let isDead = false;

    shareUrl.textContent = `üíñ Share this link with friends! üíñ ${window.location.href}`;

    // Mouse tracking for follow feature
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      mouseX = (e.clientX - rect.left) * scaleX;
      mouseY = (e.clientY - rect.top) * scaleY;
    });

    function updateDirectionFromMouse() {
      if (controlMode.value !== 'mouse') return;
      if (!myPlayer || !myPlayer.alive || !myPlayer.snake || myPlayer.snake.length === 0) return;
      
      const head = myPlayer.snake[0];
      const headX = head.x * 20 + 10;
      const headY = head.y * 20 + 10;
      
      const dx = mouseX - headX;
      const dy = mouseY - headY;
      
      // Only update if mouse is far enough from head
      if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
        let newDx = 0, newDy = 0;
        
        // Calculate the angle and determine the best direction
        const angle = Math.atan2(dy, dx);
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        
        // Choose the closest cardinal direction
        if (Math.abs(cos) > Math.abs(sin)) {
          newDx = cos > 0 ? 1 : -1;
          newDy = 0;
        } else {
          newDx = 0;
          newDy = sin > 0 ? 1 : -1;
        }
        
        targetDirection = { dx: newDx, dy: newDy };
        
        // Don't allow reversing
        if (myPlayer.direction) {
          const currentDir = myPlayer.direction;
          if (!(targetDirection.dx === -currentDir.dx && targetDirection.dy === -currentDir.dy)) {
            // Throttle direction sends
            const now = Date.now();
            if (now - lastDirectionSend > 50) {
              socket.emit('direction', targetDirection);
              lastDirectionSend = now;
            }
          }
        }
      }
    }

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      if (controlMode.value !== 'keyboard') return;
      
      const key = e.key;
      let dx = 0, dy = 0;
      if (key === 'ArrowUp' || key === 'w' || key === 'W') { dx = 0; dy = -1; }
      else if (key === 'ArrowDown' || key === 's' || key === 'S') { dx = 0; dy = 1; }
      else if (key === 'ArrowLeft' || key === 'a' || key === 'A') { dx = -1; dy = 0; }
      else if (key === 'ArrowRight' || key === 'd' || key === 'D') { dx = 1; dy = 0; }
      else return;

      e.preventDefault();
      if (dx !== 0 || dy !== 0) {
        targetDirection = { dx, dy };
        
        // Don't allow reversing
        if (myPlayer && myPlayer.direction) {
          const currentDir = myPlayer.direction;
          if (!(dx === -currentDir.dx && dy === -currentDir.dy)) {
            socket.emit('direction', { dx, dy });
          }
        }
      }
    });

    // Connection status
    socket.on('connect', () => {
      console.log('Connected to server!');
      loadingStatus.textContent = '‚úÖ Connected! Loading game...';
      myId = socket.id;
    });

    socket.on('connect_error', (error) => {
      console.log('Connection error:', error);
      loadingStatus.textContent = '‚ùå Connection error. Refreshing...';
      setTimeout(() => {
        window.location.reload();
      }, 3000);
    });

    socket.on('disconnect', () => {
      console.log('Disconnected from server');
      loadingStatus.textContent = 'üîÑ Disconnected. Reconnecting...';
    });

    document.querySelectorAll('.skin-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.skin-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        currentSkin = parseInt(btn.dataset.skin);
        if (myId && myPlayer && myPlayer.alive) {
          socket.emit('changeSkin', currentSkin);
        }
      });
    });

    joinBtn.addEventListener('click', () => {
      const name = nameInput.value.trim() || 'Cutie';
      socket.emit('join', { name, skin: currentSkin });
      loadingStatus.textContent = '‚ú® Joining game...';
      joinBtn.disabled = true;
      isDead = false;
    });

    respawnBtn.addEventListener('click', () => {
      const name = nameInput.value.trim() || 'Cutie';
      console.log('Respawning with name:', name, 'skin:', currentSkin);
      socket.emit('respawn', { name, skin: currentSkin });
      respawnOverlay.style.display = 'none';
      loadingStatus.textContent = '‚ú® Respawning...';
      loadingStatus.style.display = 'block';
      isDead = false;
    });

    socket.on('gameState', (state) => {
      players = state.players;
      food = state.food;
      
      // Update my player reference
      if (myId && players[myId]) {
        const wasAlive = myPlayer ? myPlayer.alive : true;
        myPlayer = players[myId];
        
        // Check if I just died
        if (wasAlive && !myPlayer.alive && !isDead) {
          console.log('Player died, showing respawn overlay');
          respawnOverlay.style.display = 'flex';
          loadingStatus.style.display = 'none';
          isDead = true;
        }
        
        // Check if I just respawned
        if (!wasAlive && myPlayer.alive) {
          console.log('Player respawned');
          loadingStatus.textContent = 'üéÆ Respawned!';
          setTimeout(() => {
            loadingStatus.style.display = 'none';
          }, 2000);
          isDead = false;
        }
      }
      
      loadingStatus.textContent = 'üéÆ Game loaded!';
      setTimeout(() => {
        if (myPlayer && myPlayer.alive) {
          loadingStatus.style.display = 'none';
        }
      }, 2000);
      
      updateScoreboard();
      drawCanvas();
    });

    // Listen for respawn confirmation from server
    socket.on('respawnConfirmed', () => {
      console.log('Respawn confirmed by server');
      respawnOverlay.style.display = 'none';
    });

    function updateScoreboard() {
      const count = Object.keys(players).length;
      scoreboard.textContent = `Players: ${count} üíï`;
    }

    function drawSnakeSegment(x, y, skin, isHead = false, direction = null) {
      const size = 20;
      const pad = isHead ? 2 : 4;
      const rectX = x * size + pad/2;
      const rectY = y * size + pad/2;
      const w = size - pad;
      const h = size - pad;

      ctx.save();
      
      ctx.shadowColor = '#b4ffb4';
      ctx.shadowBlur = 8;
      
      // Colors: 0=Light Yellow, 1=Lime, 2=Light Green
      if (skin === 0) { // Light Yellow
        ctx.fillStyle = '#ffff7f';
        ctx.beginPath();
        ctx.roundRect(rectX, rectY, w, h, 5);
        ctx.fill();
      } else if (skin === 1) { // Lime
        ctx.fillStyle = '#bfff6f';
        ctx.beginPath();
        ctx.roundRect(rectX, rectY, w, h, 5);
        ctx.fill();
        // Tiny stripes for lime
        ctx.strokeStyle = '#9fdf4f';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(rectX + w*0.3, rectY);
        ctx.lineTo(rectX + w*0.3, rectY + h);
        ctx.stroke();
      } else if (skin === 2) { // Light Green
        ctx.fillStyle = '#b4ffb4';
        ctx.beginPath();
        ctx.roundRect(rectX, rectY, w, h, 5);
        ctx.fill();
        // Tiny checker dots for light green
        ctx.fillStyle = '#8fdf8f';
        ctx.beginPath();
        ctx.arc(rectX + w*0.3, rectY + h*0.3, 1.5, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rectX + w*0.7, rectY + h*0.7, 1.5, 0, Math.PI*2);
        ctx.fill();
      }

      // Draw CUTE EYES on head!
      if (isHead) {
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(rectX + w*0.35, rectY + h*0.4, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rectX + w*0.65, rectY + h*0.4, 3, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = '#48284a';
        ctx.beginPath();
        ctx.arc(rectX + w*0.35, rectY + h*0.4, 1.5, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rectX + w*0.65, rectY + h*0.4, 1.5, 0, Math.PI*2);
        ctx.fill();
        
        // Blush
        ctx.fillStyle = '#ffa5c3';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(rectX + w*0.2, rectY + h*0.7, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rectX + w*0.8, rectY + h*0.7, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        // Tiny sparkle
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(rectX + w*0.3, rectY + h*0.3, 1, 0, Math.PI*2);
        ctx.fill();
        
        // Direction indicator (tiny heart in direction of movement)
        if (direction) {
          ctx.fillStyle = '#ff6f9f';
          ctx.globalAlpha = 0.8;
          if (direction.dx === 1) { // Right
            ctx.beginPath();
            ctx.arc(rectX + w*0.8, rectY + h*0.5, 2, 0, Math.PI*2);
            ctx.fill();
          } else if (direction.dx === -1) { // Left
            ctx.beginPath();
            ctx.arc(rectX + w*0.2, rectY + h*0.5, 2, 0, Math.PI*2);
            ctx.fill();
          } else if (direction.dy === -1) { // Up
            ctx.beginPath();
            ctx.arc(rectX + w*0.5, rectY + h*0.2, 2, 0, Math.PI*2);
            ctx.fill();
          } else if (direction.dy === 1) { // Down
            ctx.beginPath();
            ctx.arc(rectX + w*0.5, rectY + h*0.8, 2, 0, Math.PI*2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }
      }
      
      ctx.restore();
    }

    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.quadraticCurveTo(x + w, y, x + w, y + r);
      this.lineTo(x + w, y + h - r);
      this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      this.lineTo(x + r, y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r);
      this.lineTo(x, y + r);
      this.quadraticCurveTo(x, y, x + r, y);
      this.closePath();
      return this;
    };

    function drawCanvas() {
      ctx.clearRect(0, 0, 800, 600);

      // Draw floating bubbles on canvas
      for (let i = 0; i < 5; i++) {
        ctx.save();
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(100 + i * 150, 100 + i * 80, 30, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      
      // Draw cute strawberries
      food.forEach(f => {
        ctx.save();
        ctx.shadowColor = '#b4ffb4';
        ctx.shadowBlur = 12;
        
        ctx.fillStyle = '#ff6f9f';
        ctx.beginPath();
        ctx.arc(f.x*20 + 10, f.y*20 + 8, 7, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = '#ffffb0';
        ctx.beginPath();
        ctx.arc(f.x*20 + 7, f.y*20 + 5, 1.5, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(f.x*20 + 13, f.y*20 + 9, 1.5, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(f.x*20 + 9, f.y*20 + 13, 1.5, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = '#9fd99f';
        ctx.beginPath();
        ctx.ellipse(f.x*20 + 10, f.y*20 + 2, 3, 2, 0, 0, Math.PI*2);
        ctx.fill();
        
        ctx.restore();
      });

      // Draw snake bodies
      for (let id in players) {
        const p = players[id];
        if (!p.alive) continue;
        for (let i = 1; i < p.snake.length; i++) {
          drawSnakeSegment(p.snake[i].x, p.snake[i].y, p.skin, false);
        }
      }
      
      // Draw snake heads and names
      for (let id in players) {
        const p = players[id];
        if (!p.alive) continue;
        const head = p.snake[0];
        drawSnakeSegment(head.x, head.y, p.skin, true, p.direction);

        ctx.save();
        ctx.font = 'bold 16px "Comic Neue", "Fredoka", cursive';
        ctx.fillStyle = '#4f7a4f';
        ctx.shadowColor = 'white';
        ctx.shadowBlur = 6;
        ctx.fillText(`‚ú®${p.name}‚ú®`, head.x*20 - 20, head.y*20 - 12);
        ctx.restore();
      }

      // Draw mouse follower indicator (only in mouse mode and when alive)
      if (controlMode.value === 'mouse' && myPlayer && myPlayer.alive && myPlayer.snake && myPlayer.snake.length > 0) {
        const head = myPlayer.snake[0];
        const headX = head.x * 20 + 10;
        const headY = head.y * 20 + 10;
        
        ctx.save();
        
        // Draw direction arrow
        const angle = Math.atan2(mouseY - headY, mouseX - headX);
        const distance = Math.sqrt((mouseX - headX)**2 + (mouseY - headY)**2);
        
        if (distance > 20) {
          // Draw dashed line
          ctx.strokeStyle = '#ff6f9f';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(headX, headY);
          ctx.lineTo(mouseX, mouseY);
          ctx.stroke();
          
          // Draw arrow head
          ctx.setLineDash([]);
          ctx.fillStyle = '#ff6f9f';
          ctx.shadowColor = '#ffb6d9';
          ctx.shadowBlur = 10;
          
          // Draw target circle
          ctx.beginPath();
          ctx.arc(mouseX, mouseY, 10, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw arrow direction indicator
          ctx.fillStyle = 'white';
          ctx.font = '16px "Comic Neue"';
          ctx.fillText('üëâ', mouseX - 12, mouseY + 6);
        }
        
        ctx.restore();
      }
    }

    // Animation loop for smooth mouse following
    function gameLoop() {
      if (controlMode.value === 'mouse') {
        updateDirectionFromMouse();
      }
      animationFrame = requestAnimationFrame(gameLoop);
    }
    
    gameLoop();

    // Auto-join on page load
    window.onload = () => {
      setTimeout(() => {
        const name = nameInput.value.trim() || 'Cutie';
        socket.emit('join', { name, skin: currentSkin });
        joinBtn.disabled = true;
      }, 1000);
    };

    // Cleanup
    window.onbeforeunload = () => {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
    };
  </script>
</body>
</html>
