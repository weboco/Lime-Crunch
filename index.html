<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚ú® Cute Square Snakes ‚ú®</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: 'Comic Neue', 'Segoe UI', 'Fredoka', cursive, sans-serif;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(145deg, #ffd1dc 0%, #ffe4f3 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow: hidden;
    }
    /* Floating hearts background */
    body::before {
      content: "‚ù§Ô∏èüß°üíõüíöüíôüíú";
      position: absolute;
      font-size: 40px;
      opacity: 0.1;
      white-space: nowrap;
      animation: float 20s linear infinite;
      width: 200%;
    }
    @keyframes float {
      0% { transform: translateX(-100%) rotate(0deg); }
      100% { transform: translateX(100%) rotate(360deg); }
    }
    .game-container {
      background: #fff0f7;
      padding: 2rem 2rem 1.5rem;
      border-radius: 4rem;
      box-shadow: 0 20px 40px rgba(255, 150, 200, 0.5), inset 0 0 0 4px #ffb6d9;
      border: 4px solid white;
      position: relative;
      z-index: 2;
    }
    canvas {
      display: block;
      margin: 0 auto;
      border-radius: 3rem;
      box-shadow: 0 0 0 6px white, 0 20px 30px rgba(255, 100, 150, 0.5);
      background-color: #ffeef5;
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><text x="0" y="20" font-size="20">üêç</text></svg>') 12 12, auto;
    }
    .panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1.5rem;
      gap: 2rem;
      flex-wrap: wrap;
    }
    .left {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
    }
    input, button {
      background: #ffe5f1;
      border: 3px solid #ffa5c3;
      color: #b4466b;
      padding: 0.7rem 1.5rem;
      border-radius: 3rem;
      font-size: 1.1rem;
      font-weight: 600;
      outline: none;
      transition: all 0.2s;
    }
    input::placeholder {
      color: #ffb0cc;
    }
    button {
      background: #ffc1df;
      color: #8f3b5c;
      border: none;
      box-shadow: 0 5px 0 #ff80b0;
      cursor: pointer;
      font-weight: bold;
      transform: translateY(0);
    }
    button:active {
      box-shadow: 0 2px 0 #ff80b0;
      transform: translateY(3px);
    }
    .skin-selector {
      display: flex;
      gap: 0.8rem;
    }
    .skin-btn {
      width: 3rem;
      height: 3rem;
      border-radius: 1.5rem;
      border: 3px solid white;
      transition: 0.1s;
      cursor: pointer;
      box-shadow: 0 4px 0 #ffb0cc;
    }
    .skin-btn[data-skin="0"] {
      background: #c3ff9e;
    }
    .skin-btn[data-skin="1"] {
      background: repeating-linear-gradient(45deg, #fffac2 0px, #fffac2 8px, #ffe69b 8px, #ffe69b 16px);
    }
    .skin-btn[data-skin="2"] {
      background: radial-gradient(circle at 40% 40%, #b4ffb4, #9fd99f);
    }
    .skin-btn.selected {
      border-color: #ff4d8c;
      transform: scale(1.15);
      box-shadow: 0 0 20px #ffb6d9;
    }
    .scoreboard {
      color: #ff6f9f;
      font-weight: bold;
      background: #fff0f7;
      padding: 0.6rem 1.5rem;
      border-radius: 3rem;
      border: 3px solid #ffb6d9;
      font-size: 1.1rem;
    }
    .share-link {
      margin-top: 1.2rem;
      text-align: center;
      color: #ff8cb0;
      font-size: 0.9rem;
      background: #fff9fc;
      padding: 0.5rem;
      border-radius: 2rem;
    }
    h2 {
      text-align: center;
      color: #ff69a4;
      margin: 0 0 0.5rem 0;
      font-size: 2rem;
      text-shadow: 2px 2px 0 white;
    }
  </style>
  <script src="/socket.io/socket.io.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
  <div class="game-container">
    <h2>üêç Cute Square Snakes üêç</h2>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div class="panel">
      <div class="left">
        <input type="text" id="nameInput" placeholder="Your name" maxlength="16" value="Cutie">
        <div class="skin-selector" id="skinSelector">
          <div class="skin-btn selected" data-skin="0" title="Lime cutie"></div>
          <div class="skin-btn" data-skin="1" title="Honey stripes"></div>
          <div class="skin-btn" data-skin="2" title="Mint checker"></div>
        </div>
        <button id="joinBtn">‚ú® Play ‚ú®</button>
      </div>
      <div class="scoreboard" id="scoreboard">Players: 0</div>
    </div>
    <div class="share-link" id="shareUrl"></div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nameInput = document.getElementById('nameInput');
    const joinBtn = document.getElementById('joinBtn');
    const scoreboard = document.getElementById('scoreboard');
    const shareUrl = document.getElementById('shareUrl');

    const socket = io();

    let players = {};
    let food = [];
    let myId = null;
    let currentSkin = 0;

    shareUrl.textContent = `üíñ Share this link with friends! üíñ ${window.location.href}`;

    document.querySelectorAll('.skin-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.skin-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        currentSkin = parseInt(btn.dataset.skin);
        if (myId) {
          socket.emit('changeSkin', currentSkin);
        }
      });
    });

    joinBtn.addEventListener('click', () => {
      const name = nameInput.value.trim() || 'Cutie';
      socket.emit('join', { name, skin: currentSkin });
    });

    window.addEventListener('keydown', (e) => {
      const key = e.key;
      let dx = 0, dy = 0;
      if (key === 'ArrowUp' || key === 'w' || key === 'W') { dx = 0; dy = -1; }
      else if (key === 'ArrowDown' || key === 's' || key === 'S') { dx = 0; dy = 1; }
      else if (key === 'ArrowLeft' || key === 'a' || key === 'A') { dx = -1; dy = 0; }
      else if (key === 'ArrowRight' || key === 'd' || key === 'D') { dx = 1; dy = 0; }
      else return;

      e.preventDefault();
      if (dx !== 0 || dy !== 0) {
        socket.emit('direction', { dx, dy });
      }
    });

    socket.on('gameState', (state) => {
      players = state.players;
      food = state.food;
      if (!myId && socket.id) {
        myId = socket.id;
      }
      updateScoreboard();
      drawCanvas();
    });

    socket.on('connect', () => {
      myId = socket.id;
    });

    function updateScoreboard() {
      const count = Object.keys(players).length;
      scoreboard.textContent = `Players: ${count} üíï`;
    }

    function drawSnakeSegment(x, y, skin, isHead = false, direction = null) {
      const size = 20;
      const pad = isHead ? 2 : 4;
      const rectX = x * size + pad/2;
      const rectY = y * size + pad/2;
      const w = size - pad;
      const h = size - pad;

      ctx.save();
      
      // Draw rounded squares for cuteness
      ctx.shadowColor = '#ffb6d9';
      ctx.shadowBlur = 8;
      
      if (skin === 0) {
        ctx.fillStyle = '#c3ff9e';
        ctx.beginPath();
        ctx.roundRect(rectX, rectY, w, h, 5);
        ctx.fill();
      } else if (skin === 1) {
        ctx.fillStyle = '#fffac2';
        ctx.beginPath();
        ctx.roundRect(rectX, rectY, w, h, 5);
        ctx.fill();
        // stripes
        ctx.strokeStyle = '#ffe69b';
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(rectX + i*6, rectY);
          ctx.lineTo(rectX + i*6, rectY + h);
          ctx.stroke();
        }
      } else if (skin === 2) {
        const grad = ctx.createRadialGradient(rectX+4, rectY+4, 2, rectX+10, rectY+10, 15);
        grad.addColorStop(0, '#b4ffb4');
        grad.addColorStop(1, '#9fd99f');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.roundRect(rectX, rectY, w, h, 5);
        ctx.fill();
      }

      // Draw CUTE EYES on head!
      if (isHead) {
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(rectX + w*0.35, rectY + h*0.4, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rectX + w*0.65, rectY + h*0.4, 3, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = '#48284a';
        ctx.beginPath();
        ctx.arc(rectX + w*0.35, rectY + h*0.4, 1.5, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rectX + w*0.65, rectY + h*0.4, 1.5, 0, Math.PI*2);
        ctx.fill();
        
        // Blush
        ctx.fillStyle = '#ffa5c3';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(rectX + w*0.2, rectY + h*0.7, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(rectX + w*0.8, rectY + h*0.7, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        // Tiny sparkle
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(rectX + w*0.3, rectY + h*0.3, 1, 0, Math.PI*2);
        ctx.fill();
      }
      
      ctx.restore();
    }

    // Helper for rounded rectangles
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      this.moveTo(x + r, y);
      this.lineTo(x + w - r, y);
      this.quadraticCurveTo(x + w, y, x + w, y + r);
      this.lineTo(x + w, y + h - r);
      this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      this.lineTo(x + r, y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r);
      this.lineTo(x, y + r);
      this.quadraticCurveTo(x, y, x + r, y);
      this.closePath();
      return this;
    };

    function drawCanvas() {
      ctx.clearRect(0, 0, 800, 600);

      // NO GRID LINES - just cute background
      
      // Draw food as cute strawberries/hearts
      food.forEach(f => {
        ctx.save();
        ctx.shadowColor = '#ffb6d9';
        ctx.shadowBlur = 12;
        
        // Cute strawberry
        ctx.fillStyle = '#ff6f9f';
        ctx.beginPath();
        ctx.arc(f.x*20 + 10, f.y*20 + 8, 7, 0, Math.PI*2);
        ctx.fill();
        
        // Seeds
        ctx.fillStyle = '#ffffb0';
        ctx.beginPath();
        ctx.arc(f.x*20 + 7, f.y*20 + 5, 1.5, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(f.x*20 + 13, f.y*20 + 9, 1.5, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(f.x*20 + 9, f.y*20 + 13, 1.5, 0, Math.PI*2);
        ctx.fill();
        
        // Leaf
        ctx.fillStyle = '#9fd99f';
        ctx.beginPath();
        ctx.ellipse(f.x*20 + 10, f.y*20 + 2, 3, 2, 0, 0, Math.PI*2);
        ctx.fill();
        
        ctx.restore();
      });

      // Draw snake bodies
      for (let id in players) {
        const p = players[id];
        if (!p.alive) continue;
        for (let i = 1; i < p.snake.length; i++) {
          drawSnakeSegment(p.snake[i].x, p.snake[i].y, p.skin, false);
        }
      }
      
      // Draw snake heads and names
      for (let id in players) {
        const p = players[id];
        if (!p.alive) continue;
        const head = p.snake[0];
        drawSnakeSegment(head.x, head.y, p.skin, true, p.direction);

        // Cute name tag
        ctx.save();
        ctx.font = 'bold 16px "Comic Neue", "Fredoka", cursive';
        ctx.fillStyle = '#ff69a4';
        ctx.shadowColor = 'white';
        ctx.shadowBlur = 6;
        ctx.fillText(`‚ú®${p.name}‚ú®`, head.x*20 - 20, head.y*20 - 12);
        ctx.restore();
      }
    }

    window.onload = () => {
      socket.emit('join', { name: nameInput.value, skin: currentSkin });
    };
  </script>
</body>
</html>
